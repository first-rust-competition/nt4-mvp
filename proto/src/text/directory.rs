//! Strongly-typed message bodies for messages related to metadata about values
//! The messages here can be used to query, and subscribe to changes in metadata for values stored in the server.

use super::MessageBody;
use crate::text::DataType;
use serde::{Deserialize, Serialize};

/// Get Directory Message
///
/// Sent by a client to query what keys are currently published that begin with the given `prefix`.
/// This message is responded to with [`Directory`], containing each item in the directory
/// specified by the prefix.
///
/// [`Directory`]: ./struct.Directory.html
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct List {
    /// The prefix to search for. Each value returned in the response message will begin will this value.
    prefix: String,
}

/// Directory Response Message
///
/// Sent by a server in response to [`List`]. Contains a Vec of each item starting with the prefix specified by the client.
/// The items returned in this message do **not** contain the values associated with each key, however they do contain an identifier
/// that can be used by the client in the [`GetValues`] or [`Subscribe`] messages to query the value, or subscribe to value changes for the given key.
///
/// [`List`]: ./struct.List.html
/// [`GetValues`]: ../subscription/struct.GetValues.html
/// [`Subscribe`]: ../subscription/struct.Subscribe.html
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct Directory {
    /// The Vec of items present in the directory
    items: Vec<DirectoryItem>,
}

/// An item in a directory
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct DirectoryItem {
    /// The name of the item
    name: String,
    /// The identifier used by the server when transmitting CBOR messages containing value updates.
    ///
    /// This id can be used with the [`GetValues`] or [`Subscribe`] messages to obtain the current value of this item,
    /// or to subscribe for future value updates.
    ///
    /// [`GetValues`]: ../subscription/struct.GetValues.html
    /// [`Subscribe`]: ../subscription/struct.Subscribe.html
    id: u32,
    /// The type of data stored at this item
    #[serde(rename = "type")]
    _type: DataType,
    /// Whether this item is persistently stored to disk.
    /// If this value is false then the key will be forgotten when the server is restarted.
    persistent: bool,
}

/// Start Announcements Message
///
/// Sent by a client to indicate to the server that the client wants information about keys currently published with a given prefix
/// as well as to subscribe to changes in keys with this prefix.
///
/// The server will initially send [`Announce`] messages for each key that matches this prefix, in a way that functions similar to the [`Directory`] message.
/// Once these initial messages have been sent, the server will asynchronously send [`Announce`] and [`Unannouce`] messages as keys are added and removed.
///
/// When the client no longer wishes to hear these updates, it can send [`Unlisten`] to stop the server from sending these messages.
///
/// [`Directory`]: ./struct.Directory.html
/// [`Announce`]: ./struct.Announce.html
/// [`Unannounce`]: ./struct.Unannounce.html
/// [`Unlisten`]: ./struct.Unlisten.html
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct Listen {
    /// The prefix of the keys the client wishes to be informed of
    prefix: String,
    /// A unique listener ID generated by the client. This value will also be used later when the client wishes to stop listening.
    listenuid: u32,
}

/// Stop Announcements Message
///
/// Sent from a client to indicate that it no longer wishes to receive [`Announce`] and [`Unannounce`] messages related to a particular prefix
///
/// The `listenuid` sent with this message must **exactly match** that sent in the [`Listen`] message.
///
/// Once this message has been received from the server it will stop asynchronously sending [`Announce`] and [`Unannounce`] messages to the client
/// related to the prefix used in the [`Listen`] message with the matching `listenuid`.
///
/// [`Announce`]: ./struct.Announce.htmlp
/// [`Listen`]: ./struct.Listen.html
/// [`Unannounce`]: ./struct.Unannounce.html
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct Unlisten {
    /// The UID used in the [`Listen`] message to begin listening to changes
    ///
    /// [`Listen`]: ./struct.Listen.html
    listenuid: u32,
}

/// Key Announcement Message
///
/// Sent asynchronously from the server to a subscribed client to notify it of a new key in a directory.
///
/// See: [`Listen`]
///
/// [`Listen`]: ./struct.Listen.html
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct Announce {
    /// The full name of the key
    name: String,
    /// The ID used by the server when publishing CBOR updates for this key. This can be used with [`GetValues`] and [`Subscribe`]
    /// to receive the value associated with this key.
    ///
    /// [`GetValues`]: ../subscription/struct.GetValues.html
    /// [`Subscribe`]: ../subscription/struct.Subscribe.html
    id: u32,
    /// The type of the data associated with this key
    #[serde(rename = "type")]
    _type: DataType,
    /// Whether this data will be persisted by the server.
    persistent: bool,
}

/// Key Removed Message
///
/// Sent asynchronously from the server to indicate to a subscribed client that a value that was previously shared by [`Announce`] has been deleted.
///
/// See: [`Listen`]
///
/// [`Listen`]: ./struct.Listen.html
/// [`Announce`]: ./struct.Announce.html
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct Unannounce {
    /// The name of the value
    name: String,
    /// The ID that was used when publishing value updates through CBOR messages.
    id: u32,
}

impl_message!(List, Directory, Listen, Unlisten, Announce, Unannounce);
